
# -- Import basic python modules
import pandas as pd
import numpy as np
from operator import itemgetter

# -- Import visualisation module
import matplotlib.pyplot as plt
from matplotlib.collections import PathCollection
from matplotlib.path import Path
from matplotlib.transforms import blended_transform_factory

# -- Import pymarthe objects
from pymarthe.utils import marthe_utils
from pymarthe.utils.shp_utils import read_shapefile
from pymarthe.mfield import MartheField

# -- Import additionnal geometry module
try:
    from shapely.geometry import Polygon, Point, LineString, MultiPoint
    from shapely.ops import unary_union
    from shapely.affinity import translate
except:
    ImportError("Could not import python `shapely` package!")


# -- Set default parameters
DEFAULT_PATH_KWARGS = {
    'alpha': .9,
    'fc': 'lightgrey',
    'lw': .4,
    'ls': '-',
    'ec': 'black'
}

DEFAULT_LAYERS_COLORBAR_KWARGS = {
    'ticks': [],
    'orientation': "horizontal",
    'location': 'top',
    'fraction': 0.07,
    'shrink': .9
}


DEFAULT_ARRAY_COLORBAR_KWARGS = {
    'orientation': "horizontal",
    'location': 'top',
    'fraction': 0.12,
    'shrink': .75
}

DEFAULT_CROSS_SECTION_LINE_KWARGS = {
    'lw': 1.6,
    'color': 'red',
    'ls': '-',
    'zorder': 50
}

DEFAULT_CROSS_SECTION_TRANSLATED_LINE_KWARGS = {
    'lw': 1.2,
    'color': 'k',
    'ls': '--',
    'alpha': .8,
    'zorder': 50
}

DEFAULT_SURFACE_KWARGS = {
    'alpha': .8,
    'lw': .8,
    'ls': '-',
    'color':'blue'
}


class CrossSection():
    """ MartheModel Cross Section Management class """

    def __init__(self, mm, cross_section_line):
        """ 


        Parameters:
        ----------
        mm (MartheModel): existing MartheModel to consider.
        cross_section_line (list/dict/str): cross line definition object.
                                            It can be:
                                                - `str` : shapefile object
                                                - `list`: list of points forming a line
                                                - `dict`: 1-key dictionary.
                                                          Accepted key words are:
                                                            - `i` or `row`: row number to draw the cross line.
                                                                            (not available for nested model)
                                                            - `j` or `column`: column number to draw the cross line.
                                                                               (not available for nested model)
                                                            - `x`: x-coordinate to draw the cross line.
                                                            - `y`: y_coordinate to draw the cross line.

        Examples:
        --------
        mm = MartheModel('model.rma')
        xs = CrossSection(mm, cross_section_line='crossline.shp')
        xs = CrossSection(mm, cross_section_line=[(235.4, 356.2), (476.1, 789.3)])
        xs = CrossSection(mm, cross_section_line={'row': 25}) # or {'i': 25}
        xs = CrossSection(mm, cross_section_line={'column': 25}) # or {'j': 34}
        xs = CrossSection(mm, cross_section_line={'x': 324.7})
        xs = CrossSection(mm, cross_section_line={'y': 546.2})
        """
        self.mm = mm
        self.modelgrid = self.get_modelgrid()
        self.set_cross_section_line(cross_section_line)


    @property
    def valid_xsnodes(self) -> np.ndarray:
        """ Valid cross section node numbers (icells) """
        _valid_xsnodes = (
            self.modelgrid
            .query(
                ' & '.join(['active == 1.',
                            'top.notnull()',
                            'bottom.notnull()',
                            'node in @self.xsnodes'])
                )
            .index
            .values
        )
        return _valid_xsnodes


    @property
    def plottable_xsnodes(self):
        """ Valid cross section node numbers for plotting purpose (icells) """
        return self.xs_df.node.values


    @property
    def offset(self):
        """ Computed offset applied to cross section line to avoid intersecting cell's border """
        return self.modelgrid[['dx','dy']].min().div(10).min()

    
    def validate_ax(self, ax):
        """ 
        Check if given axe was generated by either
        `.plot_xs()` or `plot_xs_field()` internal method

        Parameters:
        ----------
        ax (Axesubplot) : matplotlib subplot.

        Examples:
        --------
        ax = xs.plot_xs()
        xs.validate_ax(ax)

        """
        msg = 'Invalid `ax`, must be a `AxesSubplot` produced ' \
              'by the internal `.plot_xs()` method.'
        assert ax.get_gid().startswith('xs'), msg



    def get_modelgrid(self):
        """
        Return main model modelgrid with z-dimension.

        Returns:
        -------
        modelgrid (DataFrame) : MartheModel modelgrid.

        Examples:
        --------
        mg = xs.get_modelgrid() # or xs.modelgrid

        """
        # -- Load modelgrid with vertical information
        if self.mm.modelgrid is None:
            self.mm.build_modelgrid(add_z=True)
        if 'dz' not in self.mm.modelgrid.columns:
            self.mm.build_modelgrid(add_z=True)
        # -- Return fully modelgrid DataFrame
        return self.mm.modelgrid.copy(deep=True)



    def set_cross_section_line(self, xsline):
        """
        Set cross section line as LineString in attribut
        
        Parameters:
        ----------
        xsline (list/dict/str): cross line definition object.
                                It can be:
                                    - `str` : shapefile object
                                    - `list`: list of points forming a line
                                    - `dict`: 1-key dictionary.
                                              Accepted key words are:
                                                - `i` or `row`: row number to draw the cross line.
                                                                (not available for nested model)
                                                - `j` or `column`: column number to draw the cross line.
                                                                   (not available for nested model)
                                                - `x`: x-coordinate to draw the cross line.
                                                - `y`: y_coordinate to draw the cross line.
        Examples:
        ---------
        mm = MartheModel('model.rma')
        xs = CrossSection(mm, cross_section_line='crossline.shp')
        xs.set_cross_section_line([(235.4, 356.2), (476.1, 789.3)])
        xs.set_cross_section_line({'row': 25})
        """
        # -- Manage xsline geometry input
        if isinstance(xsline, LineString):
            self.xsline = xsline

        # -- Manage xsline shapefile input
        if isinstance(xsline, str):
            self.xsline = LineString(read_shapefile(xsline).loc[0, 'coords'])

        # -- Manage iterable input 
        if marthe_utils.isiterable(xsline):

            if isinstance(xsline, dict):

                # -- Assert that the dict as exactly 1 valid key
                valid_keys = ['row', 'column', 'i', 'j', 'x', 'y']
                msg = "Input dictionary must have exactly 1 of the following keys:\n"
                msg += '\n'.join([ f'\t- {s}' for s in valid_keys])
                assert (0 < len(xsline) <= 1) & (all(k in valid_keys for k in xsline.keys())), msg

                # -- Extract keys and value and model extent
                (k, v), = xsline.items()
                xmin, ymin, xmax, ymax = self.mm.get_extent()

                # -- Manage understandable 'row', 'i' input
                if k.lower() in ['row', 'i']:
                    # -- Discard nested model
                    msg = 'Building cross section by row not available for nested model. '
                    msg += "Consider using the 'y' key instead. Example: `xsline={'y': 334.3}`"
                    assert len(self.mm.rlevels) <= 1, msg

                    # -- Check row number
                    rows = self.modelgrid['i'].unique()
                    msg = f'Row number (0-based) must be {min(rows)} <= row <= {max(rows)}.'
                    assert v in rows, msg

                    # -- Build 2 representative points of the required row
                    y = (self.modelgrid
                         .query("i == @v & layer == 0")[['ycc', 'dy']]
                         .iloc[0]
                         .sum())
                    pts = [[xmin, y], [xmax, y]]

                # -- Manage understandable 'column', 'j' input
                if k.lower() in ['column', 'j']:
                    # -- Discard nested model
                    msg = 'Building cross section by column not available for nested model. '
                    msg += "Consider using the 'x' key instead. Example: `xsline={'x': 451.1}`"
                    assert len(self.mm.rlevels) <= 1, msg

                    # -- Check column number
                    cols = self.modelgrid['j'].unique()
                    msg = f'Row number (0-based) must be {min(cols)} <= row <= {max(cols)}.'
                    assert v in cols, msg

                    # -- Extract 2 representative points of the required column
                    x = (self.modelgrid
                        .query("j == @v & layer == 0")[['xcc', 'dx']]
                        .iloc[0]
                        .sum())
                    pts = [[x, ymin], [x, ymax]]

                # -- Manage x-coordinate as input
                if k.lower() == 'x':
                    # -- Assert x is in extent
                    msg = f'x-coodinate must be in model extent: {xmin} <= x <= {xmax}.'
                    assert xmin <= v <= xmax, msg

                    # -- Build 2 representative points of the required x-coordinate
                    pts = [[v, ymin], [v, ymax]]

                # -- Manage x-coordinate as input
                if k.lower() == 'y':
                    # -- Assert x is in extent
                    msg = f'y-coodinate must be in model extent: {ymin} <= y <= {ymax}.'
                    assert ymin <= v <= ymax, msg

                    # -- Build 2 representative points of the required x-coordinate
                    pts = [[xmin, v], [xmax, v]]

                # -- Build cross line from extracted points
                self.xsline = LineString(pts)

            else:
                # -- Build cross line from input point coordinates
                self.xsline = LineString(xsline)

        # -- Apply a little translation of crossSection line to avoid
        #    intersecting the exact share line between two neighbouring cells
        self.xsline_translated = translate(self.xsline, xoff=self.offset, yoff=self.offset)

        # -- Collect intersected nodes between line and model cells
        xsnodes = (
                self.modelgrid
                .loc[
                    np.tile(
                        (
                            self.modelgrid
                            .query('layer == 0')['vertices']
                            .map(Polygon)
                            .map(self.xsline_translated.intersects)
                        ),
                        reps=self.mm.nlay
                    )
                ]
                .index
                .values
            )
        # -- Store cross section nodes in attribut & build cross section dataframe
        self.xsnodes = xsnodes
        self.xs_df = self.get_xs_df()



    def get_xs_df(self):
        """
        Extract all usefull informations about crossed cells as dataframe.

        Returns:
        ----------
        xs_df (DataFrame): cross section dataframe.
                           Additional columns from modelgrid are:
                            - 'x_curv0': curvilinear abscissa of first intersection
                                         point between cell border and cross line
                            - 'x_curv1': curvilinear abscissa of second intersection
                                         point between cell border and cross line
                            - 'zvertices': cell vertices on the z-dimension

        Examples:
        --------
        xs_df = xs.get_xs_df()

        """
        xs_df = (
            # -- Start from base modelgrid
            self.modelgrid
            # -- Extract vertices of on valid nodes
            .loc[self.valid_xsnodes, 'vertices']
            # -- Convert crossed cells to shapely polygon
            .map(Polygon)
            # -- Perform intersection between valid cells and cross line
            .apply(
                lambda p: (
                    LineString(p.exterior.coords)
                    .intersection(self.xsline_translated)
                    )
                )
            # -- Manage different intersection objects (Point, MultiPoint)
            .apply(
                lambda g: [Point(p.x, p.y) for p in g.geoms]
                if isinstance(g, MultiPoint)
                else np.NaN
                )
            .dropna()
            # -- Expand series of list of points to flat points series
            .explode()
            # -- Compute curvilinear abscissa of each points
            .apply(lambda p: self.xsline_translated.project(p))
            # -- Convert to Dataframe renaming columns
            .reset_index()
            .set_axis(['node', 'x_curv'], axis=1)
            # -- Get first/last curvilinear abscissa for each crossed node into a list
            .groupby('node', group_keys=True)['x_curv']
            .apply(list)
            # -- From list to separate columns
            .transform({'x_curv0': itemgetter(0), 'x_curv1': itemgetter(1)})
            .reset_index()
            # -- Merge to main modelgrid to retrive all grid infos
            .merge(self.modelgrid, on='node')
            # -- Add vertices of each crossed cells for z-dimension
            .assign(zvertices=lambda d:
                d.apply(lambda row: [[row['x_curv0'], row['top']],
                                                         [row['x_curv0'], row['bottom']],
                                               [row['x_curv1'], row['bottom']],
                                               [row['x_curv1'], row['top']],
                                               [row['x_curv0'], row['top']]], axis=1))  
        )
        # -- Return the cross section DataFrame
        return xs_df



    def plot(self, ax=None, add_translated=False, **kwargs):
        """
        Visualize cross section line in xy-dimension.

        Parameters:
        -----------
        ax (Axesubplot, optional) : custom matplotlib subplot.
        add_translated (bool, optional): whatever plot translated cross section line
                                         Default is False.
        ***kwargs : matplotlib.axes.Axes.plot arguments.

        Returns:
        ----------
        ax (Axesubplot) : output matplotlib subplot.

        Examples:
        --------
        ax = xs.plot(lw=1.5, ls=':', color='green')
        plt.show()
        """
        # -- Prepare basic axe if not provided
        if ax is None:
            fig, ax = plt.subplots(figsize=(9, 8))

        # -- Manage cross section line kwargs
        if len(kwargs) > 0:
            kwargs['zorder'] = 50
        else:
            kwargs = DEFAULT_CROSS_SECTION_LINE_KWARGS

        # -- Perform unary union of all active outcroping polygons
        uu = unary_union( 
                (
                self.modelgrid
                # -- Giving similar node ids for each layer (from 0 to ncpl) 
                .assign(inpl=np.tile(np.arange(self.mm.ncpl), self.mm.nlay))
                # -- Take only active cells
                .query('active == 1 & inest == 0')
                # -- Group by i-nodes
                .groupby('inpl')
                # -- Take the vertices of the cell (first layer)
                .first()['vertices']
                # -- Convert into polygons
                .map(Polygon)
            )
        )
        # -- Plot active domain + borders
        ax.plot(*uu.exterior.coords.xy, 
                lw=1.5, color='k', zorder=30)
        ax.fill(*uu.exterior.coords.xy,
                color='lightgrey', alpha=.6,
                zorder=10, label='Active domain')
        # -- Plot real cross line 
        ax.plot(*self.xsline.coords.xy,
                label ='Cross-section line', **kwargs)
        # -- Plot translated cross line if required
        if add_translated:
            ax.plot(*self.xsline_translated.coords.xy,
                    label='Cross-section line (translated)',
                    **DEFAULT_CROSS_SECTION_TRANSLATED_LINE_KWARGS)
        # -- Add grid xy-lines
        ax.grid(color='lightgrey', lw=.4, zorder=5)
        # -- Add legend
        ax.legend()
        # -- Return axis
        return ax



    def plot_xs(self, vertical_ratio=None, extent=None, by_layer=False, rc_font=False, **kwargs):
        """
        Visualize crossed cells in xz-dimension.

        Parameters:
        -----------
        vertical_ratio (int/float, optional): ratio between x- and z- dimension.
                                    Default is None (equivalent to 'auto' aspect).

        extent (tuple/list, optional): xy-limits of the plot window.
                                       Format: (xmin, ymin, xmax, ymax).
                                       If None, window correspond to the
                                       entire model domain.
                                       Default is None.

        by_layer (bool, optional): whatever inserting a different facecolor for each layer.
                                   Note: this will add a explained colorbar referencing
                                         the layer id on top of the figure.
                                   Default is False.

        rc_font (bool, optionnal): change rc_font to 'serif', default is False.

        **kwargs: matplotlib.PathCollection arguments.
                  (ex: cmap, lw, ls, edgecolor, ...)

        Returns:
        ----------
        ax (Axesubplot) : output matplotlib subplot.

        Examples:
        --------
        ax = xs.plot_xs(by_layer=True, ec='white', lw=.3)
        plt.show()
        """
        # -- Check number of layer
        if (by_layer) & (self.mm.nlay == 1):
            warnings.warn(
                'Argument `by_layer` cannot be pass to `True` for single layer models. '\
                'It will automatically be set to `False` anyway.'
                )

        # -- Extract patches
        patches = self.xs_df['zvertices'].apply(Path)

        # -- Build a collection from rectangles patches
        collection = PathCollection(patches)

        if by_layer:
            # -- Set layer ids as array
            collection.set_array(self.xs_df['layer'].values)

            # -- Set cmap
            cm = kwargs.pop('cmap', 'tab20')
            cmap = plt.cm.get_cmap(cm, self.mm.nlay)
            collection.set_cmap(cmap)

        # ---- Prepare basic axe if not provided
        if rc_font:
            plt.rc('font', family='serif', size=10)
        fig, ax = plt.subplots(figsize=(14, 6))

        # ---- Set plot extension
        if extent is not None:
            ax.set_xlim(*extent[::2])
            ax.set_ylim(*extent[1::2])
        else:
            # -- Extract xz-limits
            xmin = np.min(self.xs_df[['x_curv0', 'x_curv1']].values)
            xmax = np.max(self.xs_df[['x_curv0', 'x_curv1']].values)
            zmin = np.min(self.xs_df[['top', 'bottom']].values)
            zmax = np.max(self.xs_df[['top', 'bottom']].values)
            # -- Set xz-limits 
            ax.set_xlim(xmin, xmax)
            ax.set_ylim(zmin, zmax)

        # -- Hide top axis
        ax.spines['top'].set_visible(False)

        # -- Add collection default then user kwargs
        collection.set(**DEFAULT_PATH_KWARGS)
        collection.set(**kwargs)

        # ---- Add collection object to main axe
        ax.add_collection(collection)

        # -- Set color to each distinct layer
        if by_layer:
            # -- Build horizontal discrete colorbar
            bounds = np.arange(0, self.mm.nlay)
            cb = plt.colorbar(
                ax=ax,
                mappable=ax.collections[0],
                boundaries=bounds,
                **DEFAULT_LAYERS_COLORBAR_KWARGS
            )

            # -- Remove colorbar ticks 
            cb.ax.tick_params(axis='x',  size=0)

            # -- Write layer ids inside colorbar
            for i, v in enumerate(bounds):
                cb.ax.text(x=i + 0.5, y=.4, s=str(int(v)), ha='center', va='center')

            # -- Set colorbar outline properties 
            cb.outline.set(**{'lw': .7, 'color': 'k'})

            # -- Add title to colorbar
            cb.ax.set_title('LAYERS', loc='center')

            # -- Add an id to axesubplot
            ax.set_gid('xs_layer')

        else:
            # -- Add an id to axesubplot
            ax.set_gid('xs')

        # -- Set vertical ratio if required
        if vertical_ratio is not None:
            ax.set_aspect(vertical_ratio)

        # ---- Return axe
        return ax




    def plot_xs_field(self, field='permh',
                            log=False,
                            vmin=None,
                            vmax=None,
                            cmap='viridis', 
                            vertical_ratio=None,
                            extent=None,
                            cb_kwargs={},
                            rc_font=False,
                            **kwargs):
        """
        Visualize crossed cells in xz-dimension filled by given field values.

        Parameters:
        -----------
        field (str/MartheField, optional): field to consider.
                                           Default is 'permh'.

        log (bool, optional) : whatever perform logaritmic transformation on field values.
                               Default is False.

        vmin, vmax (float, optional) : min/max field value(s) to plot.

        cmap (str, optional): matplotlib colormap name.
                              Default is 'viridis'.

        vertical_ratio (int/float, optional): ratio between x- and z- dimension.
                                    Default is None (equivalent to 'auto' aspect).

        extent (tuple/list, optional): xy-limits of the plot window.
                                       Format: (xmin, ymin, xmax, ymax).
                                       If None, window correspond to the
                                       entire model domain.
                                       Default is None.

        cb_kwargs (dict, optional): colorbar arguments to customized generated colorbar.
                                    (ex: {'shrink': .75, 'location': 'bottom'})
                                    Default is {}.

        rc_font (bool, optionnal): change rc_font to 'serif', default is False.

        **kwargs: matplotlib.PathCollection arguments.
                  (ex: lw, ls, edgecolor, ...)

        Returns:
        ----------
        ax (Axesubplot) : output matplotlib subplot.

        Examples:
        --------
        ax = xs.plot_xs(by_layer=True, ec='white', lw=.3)
        plt.show()

        """

        # -- Manage field input and extract data from it
        if isinstance(field, str):
            if not field in self.mm.prop.keys():
                self.mm.load_prop(field)
            rec = self.mm.prop[field].get_data()
            field_name = field
        elif isinstance(field, MartheField):
            rec = field.get_data()
            field_name = field.field
        else:
            msg = '`field` argument must be either a `str` of a valid property field' \
                  f' or a `MartheField` instance. Given {type(field)}.'
            raise TypeError(msg)

        # -- Extract patches
        patches = self.xs_df['zvertices'].apply(Path)

        # -- Build a collection from rectangles patches
        collection = PathCollection(patches)

        # ---- Prepare basic axe if not provided
        if rc_font:
            plt.rc('font', family='serif', size=10)
        fig, ax = plt.subplots(figsize=(14, 6))

        # ---- Set plot extension
        if extent is not None:
            ax.set_xlim(*extent[::2])
            ax.set_ylim(*extent[1::2])
        else:
            # -- Extract xz-limits
            xmin = np.min(self.xs_df[['x_curv0', 'x_curv1']].values)
            xmax = np.max(self.xs_df[['x_curv0', 'x_curv1']].values)
            zmin = np.min(self.xs_df[['top', 'bottom']].values)
            zmax = np.max(self.xs_df[['top', 'bottom']].values)
            # -- Set xz-limits 
            ax.set_xlim(xmin, xmax)
            ax.set_ylim(zmin, zmax)

        # -- Hide top axis
        ax.spines['top'].set_visible(False)

        # -- Add collection default then user kwargs
        collection.set(**DEFAULT_PATH_KWARGS)
        collection.set(**kwargs)

        # -- Extract data on cross section cells and apply log-transformation if required
        if log:
            arr = np.log10(rec['value'][self.valid_xsnodes])
        else:
            arr = rec['value'][self.valid_xsnodes]

        # -- Set values of each intersected cell
        collection.set_array(arr)

        # -- Set colormap to collections
        collection.set_cmap(cmap)

        # ---- Add collection object to main axe
        ax.add_collection(collection)

        # -- Set default values limites
        vmin = arr.min() if vmin is None else vmin
        vmax = arr.max() if vmax is None else vmax
        collection.set_clim(vmin=vmin, vmax=vmax)

        # -- Build a normalized scalar mappable object
        norm = plt.Normalize(vmin, vmax)
        sm = plt.cm.ScalarMappable(cmap=cmap, norm=norm)

        # -- Build colorbar with/without default parameters
        label = f'log({field_name})' if log else field_name
        cb_kwargs = cb_kwargs if len(cb_kwargs) > 0 else DEFAULT_ARRAY_COLORBAR_KWARGS
        cb = plt.colorbar(sm, ax=ax, label=label, **cb_kwargs)

        # -- Add an id to optional colorbar
        ax.set_gid('xs_field')

        # -- Set vertical ratio if required
        if vertical_ratio is not None:
            ax.set_aspect(vertical_ratio)

        # ---- Return axe
        return cb, ax


    def add_location(self, ax, loc, tolerance=None, text_kws=None, **kwargs):
        """
        Adding a vertical line to a cross section plot from xy-coordinates.

        Parameters:
        -----------
        ax (AxeSubplot): existing axe generated by `.plot_xs()`
                         or `.plot_xs_field()` methods.
        loc (shapely.geometry.Point/iterable): points xy-coordinates.
        tolerance (float/int/None, optional): distance around the cross line to accept or
                                              denied plotting the vertical line on plot
        text_kws (dict, None, optional): optional `plt.text()` arguments to write in plot.
                                         If None, text will not be added.
                                         Default is None.
        **kwargs: matplotlib.AxeSubplot.axvline arguments
                  (ex: lw, ls, color, ...)
        
        Examples:
        --------
        ax = xs.plot_xs(by_layer=True)
        trans = blended_transform_factory(ax.transData, ax.transAxes)
        xs.add_location(ax, loc=(355, 291),
            tolerance=None,
            text_kws=dict(y=1.03, s='Bordeaux',
                color='red', transform=trans,
                va='center', ha='center'),
            lw=.8, color='red')
        plt.show()
        """
        # -- Validate input ax
        self.validate_ax(ax)
        # -- Extract axis x-limit
        xmin, xmax = ax.get_xlim()
        # -- Get location as shapely Point
        point = loc if isinstance(loc, Point) else Point(loc)
        # -- Assure isn't to far from the cross section line
        is_near = True if tolerance is None else point.within(self.xsline_translated.buffer(tolerance))
        # Extract curvilinear abscissa
        xcurv = self.xsline_translated.project(point)
        # -- Check if point can be plot
        if (is_near) & (xmin < xcurv < xmax):
            # Plot vertical line on giving location
            ax.axvline(x=xcurv, **kwargs)
            # Write additionnal text if required
            if text_kws is not None:
                x = text_kws.pop('x', xcurv)
                y = text_kws.pop('y', 0)
                s = text_kws.pop('s', 'loc')
                ax.text(x=x, y=y, s=s, **text_kws)



    def add_vertices_locations(self, ax, text_kws={}, prefix='', **kwargs):
        """
        Adding a vertical line to a cross section plot at cross line vertices (if exists).

        Parameters:
        -----------
        ax (AxeSubplot): existing axe generated by `.plot_xs()`
                         or `.plot_xs_field()` methods.
        text_kws (dict, optional): optional `plt.text()` arguments to write in plot.
                                   If None, text will not be added.
                                   Default is {}.
        prefix (str, optional): input prefix before vertices number.
                                Default is ''.
        **kwargs: matplotlib.AxeSubplot.axvline arguments
                  (ex: lw, ls, color, ...)
        
        Examples:
        --------
        ax = xs.plot_xs(by_layer=True)
        xs.add_vertices_locations(
            ax,
            text_kws={'color': 'red'},
            color='red'
            )
        """
        # -- Validate input ax
        self.validate_ax(ax)
        # -- Manage text kwargs
        if text_kws is None:
            text_kws = dict()
        else:
            # -- Remove 'x' and 's' key if exist
            x = text_kws.pop('x', None)
            # -- Manage custom y-transformation
            if not 'y' in text_kws.keys():
                text_kws.update(
                    {
                    'y': 1.03,
                    'transform': blended_transform_factory(
                        ax.transData,
                        ax.transAxes
                        ),
                    'ha': 'center',
                    'va': 'center'
                    }
                )
        # -- Iterate over all cross line vertices adding vertical line
        for i, point in enumerate(self.xsline_translated.coords):
            # -- Update vertice text
            s = text_kws.get('s', prefix + str(i))
            # -- Add location with text
            self.add_location(
                ax=ax,
                loc=point,
                text_kws= {**{'s': s}, **text_kws},
                **kwargs
                )



    def add_surface(self, ax, surface, layer=None, **kwargs):
        """
        Adding a horizontal lines (surface) to a existing cross section plot

        Parameters:
        -----------
        ax (AxeSubplot): existing axe generated by `.plot_xs()`
                         or `.plot_xs_field()` methods.
        surface (MatheField|iterable): surface z-values.
                                       Must have the same length as the number of plottable nodes.
                                       Can be :
                                            - `MartheField`: it will automatically extract the
                                                             required value in the field.
                                            - 'top'|'bottom': it will consider the already
                                                              existent top, bottom coordinates of
                                                              each cells as surface.
                                            - iterable: flexible imputed that must have the same
                                                        length as the number of plottable nodes
        layer (int|iterable|None, optional): layer id to consider while plotting 
                                             surfaces.
                                             If None, all layers will be considered.
                                             Default is None.
        **kwargs: matplotlib.AxeSubplot.hlines arguments
                  (ex: lw, ls, color, alpha, ...)
        
        Examples:
        --------
        ax = xs.plot_xs(by_layer=True) 
        xs.add_surface(ax=ax, surface='bottom',
                       layer=[8, 9], lw=1.15, color='k')
        plt.show()
        """
        # -- Validate input ax
        self.validate_ax(ax)
        # -- Manage surface input
        if isinstance(surface, MartheField):
            surface = surface.data['value'][self.plottable_xsnodes]
        elif isinstance(surface, str):
            if surface.lower() in ['top', 'bottom']:
                surface = self.xs_df[surface]
        msg = f"Input `surface` must be of length {len(self.xs_df)}. "
        msg += f"Given {len(surface)}"
        assert (len(surface) == len(self.xs_df)), msg
        # -- Manage layer input
        layers = list(range(self.mm.nlay)) if layer is None else marthe_utils.make_iterable(layer)
        # -- Manage kwargs
        kwargs = {**DEFAULT_SURFACE_KWARGS, **kwargs}
        # -- Extract xz-coordinates
        xmin, xmax, surf  = np.column_stack(
            (
                self.xs_df
                .assign(surface=surface)
                .query("layer in @layers")
                [['x_curv0', 'x_curv1', 'surface']]
                .values
            )
        )
        # -- Plot horizontal lines for each cell in each layer
        lines = ax.hlines(surf, xmin, xmax, **kwargs)
